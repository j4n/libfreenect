Description: Kinect for windows
 Merge https://github.com/renewagner/libfreenect/tree/k4w-wip
 .
 libfreenect (1:0.1.2+dfsg-6) unstable; urgency=low
 .
   [ Nicolas Bourdaud ]
   * Make build system compatible with multiarch:
     - dont-postfix-to-install-libdir.patch becomes use-standard-libdir.patch
   * Bump debhelper compatibility level to 9.
   * Add multiarch support.
   * Remove useless section fields from debian/control.
   * Use dh_python2 instead of dh_pysupport.
   * Update manpages with keyboard shortcuts. (Closes: #663869)
 .
   [ Jan ]
   * merge kinect for windows support
Author: Jan <janlauff@buxtehude>
Bug-Debian: http://bugs.debian.org/663869

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- libfreenect-0.1.2+dfsg.orig/CMakeLists.txt
+++ libfreenect-0.1.2+dfsg/CMakeLists.txt
@@ -104,12 +104,6 @@ SET(CMAKE_C_FLAGS_RELWITHDEBINFO "-O2 -g
 
 add_definitions(-Wall)
 
-if (WIN32)
-  set(MATH_LIB "")
-else(WIN32)
-  set(MATH_LIB "m")
-endif()
-
 # Pretty much everyone is going to need the main includes
 include_directories (${CMAKE_CURRENT_SOURCE_DIR}/include)
 
@@ -118,7 +112,7 @@ include_directories(${LIBUSB_1_INCLUDE_D
 
 if(WIN32)
   include_directories("${CMAKE_CURRENT_SOURCE_DIR}/platform/windows")
-  include_directories("${CMAKE_CURRENT_SOURCE_DIR}/platform/windows/libusb10emu")
+  include_directories("${CMAKE_CURRENT_SOURCE_DIR}/platform/windows/libusb10emu/libusb-1.0")
 endif()
 
 # Add library project
--- libfreenect-0.1.2+dfsg.orig/src/CMakeLists.txt
+++ libfreenect-0.1.2+dfsg/src/CMakeLists.txt
@@ -3,7 +3,6 @@
 ######################################################################################
 
 include_directories (${CMAKE_CURRENT_SOURCE_DIR})
-find_package(Threads REQUIRED)
 
 set(CMAKE_C_FLAGS "-Wall")
 
@@ -46,8 +45,8 @@ ENDIF()
 install (TARGETS freenectstatic
   DESTINATION "${PROJECT_LIBRARY_INSTALL_DIR}")
 
-target_link_libraries(freenect ${LIBUSB_1_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
-target_link_libraries(freenectstatic ${LIBUSB_1_LIBRARIES} ${CMAKE_THREAD_LIBS_INIT})
+target_link_libraries (freenect ${LIBUSB_1_LIBRARIES})
+target_link_libraries (freenectstatic ${LIBUSB_1_LIBRARIES})
 
 # Install the header files
 install (FILES "../include/libfreenect.h" "../include/libfreenect-registration.h"
--- libfreenect-0.1.2+dfsg.orig/src/cameras.c
+++ libfreenect-0.1.2+dfsg/src/cameras.c
@@ -38,7 +38,7 @@
 #define RESERVED_TO_FORMAT(reserved) ((reserved) & 0xff)
 
 #define video_mode_count 12
-freenect_frame_mode supported_video_modes[video_mode_count] = {
+static freenect_frame_mode supported_video_modes[video_mode_count] = {
 	// reserved, resolution, format, bytes, width, height, data_bits_per_pixel, padding_bits_per_pixel, framerate, is_valid
 	{MAKE_RESERVED(FREENECT_RESOLUTION_HIGH,   FREENECT_VIDEO_RGB), FREENECT_RESOLUTION_HIGH, {FREENECT_VIDEO_RGB}, 1280*1024*3, 1280, 1024, 24, 0, 10, 1 },
 	{MAKE_RESERVED(FREENECT_RESOLUTION_MEDIUM, FREENECT_VIDEO_RGB), FREENECT_RESOLUTION_MEDIUM, {FREENECT_VIDEO_RGB}, 640*480*3, 640,  480, 24, 0, 30, 1 },
@@ -61,7 +61,7 @@ freenect_frame_mode supported_video_mode
 };
 
 #define depth_mode_count 6
-freenect_frame_mode supported_depth_modes[depth_mode_count] = {
+static freenect_frame_mode supported_depth_modes[depth_mode_count] = {
 	// reserved, resolution, format, bytes, width, height, data_bits_per_pixel, padding_bits_per_pixel, framerate, is_valid
 	{MAKE_RESERVED(FREENECT_RESOLUTION_MEDIUM, FREENECT_DEPTH_11BIT), FREENECT_RESOLUTION_MEDIUM, {FREENECT_DEPTH_11BIT}, 640*480*2, 640, 480, 11, 5, 30, 1},
 	{MAKE_RESERVED(FREENECT_RESOLUTION_MEDIUM, FREENECT_DEPTH_10BIT), FREENECT_RESOLUTION_MEDIUM, {FREENECT_DEPTH_10BIT}, 640*480*2, 640, 480, 10, 6, 30, 1},
@@ -903,22 +903,46 @@ static int freenect_fetch_zero_plane_inf
 	uint16_t cmd[5] = {0}; // Offset is the only field in this command, and it's 0
 
 	int res;
-	res = send_cmd(dev, 0x04, cmd, 10, reply, 322); //OPCODE_GET_FIXED_PARAMS = 4,
-	if (res != 322) {
-		FN_ERROR("freenect_fetch_zero_plane_info: send_cmd read %d bytes (expected 322)\n", res);
+
+	int expected_len = 0;
+	int struct_offset = 0;
+	switch(dev->hwrev) {
+		case HWREV_XBOX360_0:
+			expected_len = 322;
+			struct_offset = 94;
+			break;
+		case HWREV_K4W_0:
+			expected_len = 334;
+			struct_offset = 94;
+			break;
+	}
+
+	res = send_cmd(dev, 0x04, cmd, 10, reply, expected_len); //OPCODE_GET_FIXED_PARAMS = 4,
+	if (res != expected_len) {
+		FN_ERROR("freenect_fetch_zero_plane_info: send_cmd read %d bytes (expected %d)\n", res, expected_len);
 		return -1;
 	}
 
-	memcpy(&(dev->registration.zero_plane_info), reply + 94, sizeof(dev->registration.zero_plane_info));
-	uint32_t temp;
-	temp = fn_le32(*((uint32_t*)(&dev->registration.zero_plane_info.dcmos_emitter_dist)));
-	dev->registration.zero_plane_info.dcmos_emitter_dist   = *((float*)(&temp));
-	temp = fn_le32(*((uint32_t*)(&dev->registration.zero_plane_info.dcmos_rcmos_dist)));
-	dev->registration.zero_plane_info.dcmos_rcmos_dist     = *((float*)(&temp));
-	temp = fn_le32(*((uint32_t*)(&dev->registration.zero_plane_info.reference_distance)));
-	dev->registration.zero_plane_info.reference_distance   = *((float*)(&temp));
-	temp = fn_le32(*((uint32_t*)(&dev->registration.zero_plane_info.reference_pixel_size)));
-	dev->registration.zero_plane_info.reference_pixel_size = *((float*)(&temp));
+	memcpy(&(dev->registration.zero_plane_info), reply + struct_offset, sizeof(dev->registration.zero_plane_info));
+	union {
+		uint32_t ui;
+		float f;
+	} conversion_union;
+	conversion_union.f = dev->registration.zero_plane_info.dcmos_emitter_dist;
+	conversion_union.ui = fn_le32(conversion_union.ui);
+	dev->registration.zero_plane_info.dcmos_emitter_dist = conversion_union.f;
+
+	conversion_union.f = dev->registration.zero_plane_info.dcmos_rcmos_dist;
+	conversion_union.ui = fn_le32(conversion_union.ui);
+	dev->registration.zero_plane_info.dcmos_rcmos_dist = conversion_union.f;
+
+	conversion_union.f = dev->registration.zero_plane_info.reference_distance;
+	conversion_union.ui = fn_le32(conversion_union.ui);
+	dev->registration.zero_plane_info.reference_distance = conversion_union.f;
+
+	conversion_union.f = dev->registration.zero_plane_info.reference_pixel_size;
+	conversion_union.ui = fn_le32(conversion_union.ui);
+	dev->registration.zero_plane_info.reference_pixel_size = conversion_union.f;
 
 	// WTF is all this data?  it's way bigger than sizeof(XnFixedParams)...
 	FN_SPEW("dcmos_emitter_distance: %f\n", dev->registration.zero_plane_info.dcmos_emitter_dist);
@@ -1251,7 +1275,8 @@ int freenect_set_video_mode(freenect_dev
 	dev->video_resolution = res;
 	// Now that we've changed video format and resolution, we need to update
 	// registration tables.
-	freenect_fetch_reg_info(dev);
+	if (res == FREENECT_RESOLUTION_MEDIUM)
+		freenect_fetch_reg_info(dev);
 	return 0;
 }
 
@@ -1313,6 +1338,55 @@ int freenect_set_depth_mode(freenect_dev
 	dev->depth_resolution = res;
 	return 0;
 }
+
+int freenect_set_smoothing_mode(freenect_device* dev, const freenect_smoothing_mode mode)
+{
+	int retval = -1;
+	
+	switch(mode) {
+	case FREENECT_SMOOTHING_DISABLED:
+		retval = write_register(dev, 0x16, 0x00);
+		break;
+	case FREENECT_SMOOTHING_HOLE_FILLING_DEPTH_SMOOTHING_ENABLED:
+		retval = write_register(dev, 0x16, 0x01);
+		break;
+	}
+
+	return retval;
+}
+
+int freenect_set_range_mode(freenect_device* dev, const freenect_range_mode mode)
+{
+	freenect_context *ctx = dev->parent;
+
+	int retval = 0;
+	switch(mode) {
+	case FREENECT_RANGE_DEFAULT:
+		retval = write_register(dev, 0x0015, 0x001E);
+		if (retval != 0) {
+			FN_ERROR("Failed to set IR gain\n");
+			return retval;
+		}
+		if (dev->hwrev == HWREV_K4W_0) {
+			usleep(100000);
+			retval = write_register(dev, 0x02EF, 0x0190);
+		}
+		break;
+	case FREENECT_RANGE_NEAR_MODE:
+		retval = write_register(dev, 0x0015, 0x0007);
+		if (retval != 0) {
+			FN_ERROR("Failed to set IR gain\n");
+			return retval;
+		}
+		if (dev->hwrev == HWREV_K4W_0) {
+			usleep(100000);
+			retval = write_register(dev, 0x02EF, 0x0000);
+		}
+		break;
+	}
+	return retval;
+}
+
 int freenect_set_depth_buffer(freenect_device *dev, void *buf)
 {
 	return stream_setbuf(dev->parent, &dev->depth, buf);
@@ -1323,7 +1397,7 @@ int freenect_set_video_buffer(freenect_d
 	return stream_setbuf(dev->parent, &dev->video, buf);
 }
 
-int freenect_camera_init(freenect_device *dev)
+FN_INTERNAL int freenect_camera_init(freenect_device *dev)
 {
 	freenect_context *ctx = dev->parent;
 	int res;
@@ -1347,7 +1421,7 @@ int freenect_camera_init(freenect_device
 	return 0;
 }
 
-int freenect_camera_teardown(freenect_device *dev)
+FN_INTERNAL int freenect_camera_teardown(freenect_device *dev)
 {
 	freenect_context *ctx = dev->parent;
 	int res = 0;
--- libfreenect-0.1.2+dfsg.orig/src/usb_libusb10.c
+++ libfreenect-0.1.2+dfsg/src/usb_libusb10.c
@@ -33,7 +33,7 @@
 #include "freenect_internal.h"
 #include "loader.h"
 
-int fnusb_num_devices(fnusb_ctx *ctx)
+FN_INTERNAL int fnusb_num_devices(fnusb_ctx *ctx)
 {
 	libusb_device **devs; 
 	//pointer to pointer of device, used to retrieve a list of devices	
@@ -48,7 +48,7 @@ int fnusb_num_devices(fnusb_ctx *ctx)
 		int r = libusb_get_device_descriptor (devs[i], &desc);
 		if (r < 0)
 			continue;
-		if (desc.idVendor == VID_MICROSOFT && desc.idProduct == PID_NUI_CAMERA)
+		if (desc.idVendor == VID_MICROSOFT && (desc.idProduct == PID_NUI_CAMERA || desc.idProduct == PID_K4W_CAMERA))
 			nr++;
 	}
 	libusb_free_device_list (devs, 1);
@@ -56,7 +56,7 @@ int fnusb_num_devices(fnusb_ctx *ctx)
 	return nr;
 }
 
-int fnusb_list_device_attributes(fnusb_ctx *ctx, struct freenect_device_attributes** attribute_list)
+FN_INTERNAL int fnusb_list_device_attributes(fnusb_ctx *ctx, struct freenect_device_attributes** attribute_list)
 {
 	*attribute_list = NULL; // initialize some return value in case the user is careless.
 	libusb_device **devs;
@@ -77,7 +77,7 @@ int fnusb_list_device_attributes(fnusb_c
 		int r = libusb_get_device_descriptor (devs[i], &desc);
 		if (r < 0)
 			continue;
-		if (desc.idVendor == VID_MICROSOFT && desc.idProduct == PID_NUI_CAMERA) {
+		if (desc.idVendor == VID_MICROSOFT && (desc.idProduct == PID_NUI_CAMERA || desc.idProduct == PID_K4W_CAMERA)) {
 			// Verify that a serial number exists to query.  If not, don't touch the device.
 			if (desc.iSerialNumber == 0) {
 				continue;
@@ -116,11 +116,12 @@ int fnusb_list_device_attributes(fnusb_c
 	return num_cams;
 }
 
-int fnusb_init(fnusb_ctx *ctx, freenect_usb_context *usb_ctx)
+FN_INTERNAL int fnusb_init(fnusb_ctx *ctx, freenect_usb_context *usb_ctx)
 {
 	int res;
 	if (!usb_ctx) {
 		res = libusb_init(&ctx->ctx);
+		libusb_set_debug(ctx->ctx, 3);
 		if (res >= 0) {
 			ctx->should_free_ctx = 1;
 			return 0;
@@ -137,7 +138,7 @@ int fnusb_init(fnusb_ctx *ctx, freenect_
 	}
 }
 
-int fnusb_shutdown(fnusb_ctx *ctx)
+FN_INTERNAL int fnusb_shutdown(fnusb_ctx *ctx)
 {
 	//int res;
 	if (ctx->should_free_ctx) {
@@ -147,17 +148,17 @@ int fnusb_shutdown(fnusb_ctx *ctx)
 	return 0;
 }
 
-int fnusb_process_events(fnusb_ctx *ctx)
+FN_INTERNAL int fnusb_process_events(fnusb_ctx *ctx)
 {
 	return libusb_handle_events(ctx->ctx);
 }
 
-int fnusb_process_events_timeout(fnusb_ctx *ctx, struct timeval* timeout)
+FN_INTERNAL int fnusb_process_events_timeout(fnusb_ctx *ctx, struct timeval* timeout)
 {
 	return libusb_handle_events_timeout(ctx->ctx, timeout);
 }
 
-int fnusb_open_subdevices(freenect_device *dev, int index)
+FN_INTERNAL int fnusb_open_subdevices(freenect_device *dev, int index)
 {
 	freenect_context *ctx = dev->parent;
 
@@ -191,7 +192,7 @@ int fnusb_open_subdevices(freenect_devic
 			continue;
 
 		// Search for the camera
-		if ((ctx->enabled_subdevices & FREENECT_DEVICE_CAMERA) && !dev->usb_cam.dev && desc.idProduct == PID_NUI_CAMERA) {
+		if ((ctx->enabled_subdevices & FREENECT_DEVICE_CAMERA) && !dev->usb_cam.dev && (desc.idProduct == PID_NUI_CAMERA || desc.idProduct == PID_K4W_CAMERA)) {
 			// If the index given by the user matches our camera index
 			if (nr_cam == index) {
 				res = libusb_open (devs[i], &dev->usb_cam.dev);
@@ -220,13 +221,30 @@ int fnusb_open_subdevices(freenect_devic
 					dev->usb_cam.dev = NULL;
 					break;
 				}
+				if (desc.idProduct == PID_NUI_CAMERA) {
+					dev->hwrev = HWREV_XBOX360_0;
+					FN_SPEW("Opened Kinect for Xbox360 camera\n");
+				} else if (desc.idProduct == PID_K4W_CAMERA) {
+					dev->hwrev = HWREV_K4W_0;
+					FN_SPEW("Opened Kinect for Windows camera\n");
+					// Set alternate interface setting 1 to enable the two isochronous endpoints
+					res = libusb_set_interface_alt_setting(dev->usb_cam.dev, 0, 1);
+					if (res != 0) {
+						FN_ERROR("Failed to set alternate interface #1 for K4W: %d\n", res);
+						libusb_close(dev->usb_cam.dev);
+						dev->usb_cam.dev = NULL;
+						break;
+					}
+				} else {
+					FN_ERROR("Unknown hardware revision - fix fnusb_open_subdevices()\n");
+				}
 			} else {
 				nr_cam++;
 			}
 		}
 
 		// Search for the motor
-		if ((ctx->enabled_subdevices & FREENECT_DEVICE_MOTOR) && !dev->usb_motor.dev && desc.idProduct == PID_NUI_MOTOR) {
+		if ((ctx->enabled_subdevices & FREENECT_DEVICE_MOTOR) && !dev->usb_motor.dev && (desc.idProduct == PID_NUI_MOTOR)) {
 			// If the index given by the user matches our camera index
 			if (nr_mot == index) {
 				res = libusb_open (devs[i], &dev->usb_motor.dev);
@@ -250,7 +268,7 @@ int fnusb_open_subdevices(freenect_devic
 #ifdef BUILD_AUDIO
 		// TODO: check that the firmware has already been loaded; if not, upload firmware.
 		// Search for the audio
-		if ((ctx->enabled_subdevices & FREENECT_DEVICE_AUDIO) && !dev->usb_audio.dev && desc.idProduct == PID_NUI_AUDIO) {
+		if ((ctx->enabled_subdevices & FREENECT_DEVICE_AUDIO) && !dev->usb_audio.dev && (desc.idProduct == PID_NUI_AUDIO || desc.idProduct == PID_K4W_AUDIO)) {
 			// If the index given by the user matches our audio index
 			if (nr_audio == index) {
 				res = libusb_open (devs[i], &dev->usb_audio.dev);
@@ -306,7 +324,7 @@ int fnusb_open_subdevices(freenect_devic
 							if (r < 0)
 								continue;
 							// If this dev is a Kinect audio device, open device, read serial, and compare.
-							if (new_dev_desc.idVendor == VID_MICROSOFT && new_dev_desc.idProduct == PID_NUI_AUDIO) {
+							if (new_dev_desc.idVendor == VID_MICROSOFT && (new_dev_desc.idProduct == PID_NUI_AUDIO || new_dev_desc.idProduct == PID_K4W_AUDIO)) {
 								FN_SPEW("Matched VID/PID!\n");
 								libusb_device_handle* new_dev_handle;
 								// Open device
@@ -392,7 +410,7 @@ int fnusb_open_subdevices(freenect_devic
 	}
 }
 
-int fnusb_close_subdevices(freenect_device *dev)
+FN_INTERNAL int fnusb_close_subdevices(freenect_device *dev)
 {
 	if (dev->usb_cam.dev) {
 		libusb_release_interface(dev->usb_cam.dev, 0);
@@ -499,7 +517,7 @@ static void iso_callback(struct libusb_t
 	}
 }
 
-int fnusb_start_iso(fnusb_dev *dev, fnusb_isoc_stream *strm, fnusb_iso_cb cb, int ep, int xfers, int pkts, int len)
+FN_INTERNAL int fnusb_start_iso(fnusb_dev *dev, fnusb_isoc_stream *strm, fnusb_iso_cb cb, int ep, int xfers, int pkts, int len)
 {
 	freenect_context *ctx = dev->parent->parent;
 	int ret, i;
@@ -537,7 +555,7 @@ int fnusb_start_iso(fnusb_dev *dev, fnus
 
 }
 
-int fnusb_stop_iso(fnusb_dev *dev, fnusb_isoc_stream *strm)
+FN_INTERNAL int fnusb_stop_iso(fnusb_dev *dev, fnusb_isoc_stream *strm)
 {
 	freenect_context *ctx = dev->parent->parent;
 	int i;
@@ -568,17 +586,17 @@ int fnusb_stop_iso(fnusb_dev *dev, fnusb
 	return 0;
 }
 
-int fnusb_control(fnusb_dev *dev, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint8_t *data, uint16_t wLength)
+FN_INTERNAL int fnusb_control(fnusb_dev *dev, uint8_t bmRequestType, uint8_t bRequest, uint16_t wValue, uint16_t wIndex, uint8_t *data, uint16_t wLength)
 {
 	return libusb_control_transfer(dev->dev, bmRequestType, bRequest, wValue, wIndex, data, wLength, 0);
 }
 
 #ifdef BUILD_AUDIO
-int fnusb_bulk(fnusb_dev *dev, uint8_t endpoint, uint8_t *data, int len, int *transferred) {
+FN_INTERNAL int fnusb_bulk(fnusb_dev *dev, uint8_t endpoint, uint8_t *data, int len, int *transferred) {
 	return libusb_bulk_transfer(dev->dev, endpoint, data, len, transferred, 0);
 }
 
-int fnusb_num_interfaces(fnusb_dev *dev) {
+FN_INTERNAL int fnusb_num_interfaces(fnusb_dev *dev) {
 	int retval = 0;
 	int res;
 	libusb_device* d = libusb_get_device(dev->dev);
--- libfreenect-0.1.2+dfsg.orig/src/core.c
+++ libfreenect-0.1.2+dfsg/src/core.c
@@ -260,7 +260,7 @@ FREENECTAPI void freenect_set_log_callba
 	ctx->log_cb = cb;
 }
 
-void fn_log(freenect_context *ctx, freenect_loglevel level, const char *fmt, ...)
+FN_INTERNAL void fn_log(freenect_context *ctx, freenect_loglevel level, const char *fmt, ...)
 {
 	va_list ap;
 
--- libfreenect-0.1.2+dfsg.orig/src/registration.c
+++ libfreenect-0.1.2+dfsg/src/registration.c
@@ -74,7 +74,7 @@ static void freenect_init_depth_to_rgb(i
 }
 
 // unrolled inner loop of the 11-bit unpacker
-inline void unpack_8_pixels(uint8_t *raw, uint16_t *frame)
+static inline void unpack_8_pixels(uint8_t *raw, uint16_t *frame)
 {
 	uint16_t baseMask = 0x7FF;
 
@@ -101,7 +101,7 @@ inline void unpack_8_pixels(uint8_t *raw
 }
 
 // apply registration data to a single packed frame
-int freenect_apply_registration(freenect_device* dev, uint8_t* input_packed, uint16_t* output_mm)
+FN_INTERNAL int freenect_apply_registration(freenect_device* dev, uint8_t* input_packed, uint16_t* output_mm)
 {
 	freenect_registration* reg = &(dev->registration);
 	// set output buffer to zero using pointer-sized memory access (~ 30-40% faster than memset)
@@ -169,7 +169,7 @@ int freenect_apply_registration(freenect
 }
 
 // Same as freenect_apply_registration, but don't bother aligning to the RGB image
-int freenect_apply_depth_to_mm(freenect_device* dev, uint8_t* input_packed, uint16_t* output_mm)
+FN_INTERNAL int freenect_apply_depth_to_mm(freenect_device* dev, uint8_t* input_packed, uint16_t* output_mm)
 {
 	freenect_registration* reg = &(dev->registration);
 	uint16_t unpack[8];
@@ -289,9 +289,9 @@ static void freenect_init_registration_t
 }
 
 // These are just constants.
-double parameter_coefficient = 4;
-double shift_scale = 10;
-double pixel_size_factor = 1;
+static double parameter_coefficient = 4;
+static double shift_scale = 10;
+static double pixel_size_factor = 1;
 
 /// convert raw shift value to metric depth (in mm)
 static uint16_t freenect_raw_to_mm(uint16_t raw, freenect_registration* reg)
@@ -332,7 +332,7 @@ void freenect_camera_to_world(freenect_d
 /// Allocate and fill registration tables
 /// This function should be called every time a new video (not depth!) mode is
 /// activated.
-int freenect_init_registration(freenect_device* dev)
+FN_INTERNAL int freenect_init_registration(freenect_device* dev)
 {
 	freenect_registration* reg = &(dev->registration);
 
--- libfreenect-0.1.2+dfsg.orig/src/loader.c
+++ libfreenect-0.1.2+dfsg/src/loader.c
@@ -49,14 +49,15 @@ static void dump_cemd_cmd(freenect_conte
 static int get_reply(fnusb_dev* dev) {
 	freenect_context* ctx = dev->parent->parent;
 	unsigned char dump[512];
-	bootloader_status_code buffer = ((bootloader_status_code*)dump)[0];
+	bootloader_status_code buffer;
 	int res;
 	int transferred;
-	res = fnusb_bulk(dev, 0x81, (unsigned char*)&buffer, 512, &transferred);
+	res = fnusb_bulk(dev, 0x81, dump, 512, &transferred);
 	if(res != 0 || transferred != sizeof(bootloader_status_code)) {
 		FN_ERROR("Error reading reply: %d\ttransferred: %d (expected %d)\n", res, transferred, (int)(sizeof(bootloader_status_code)));
 		return res;
 	}
+	memcpy(&buffer, dump, sizeof(bootloader_status_code));
 	if(fn_le32(buffer.magic) != 0x0a6fe000) {
 		FN_ERROR("Error reading reply: invalid magic %08X\n",buffer.magic);
 		return -1;
@@ -119,7 +120,7 @@ static int check_version_string(fnusb_de
 	return res;
 }
 
-int upload_firmware(fnusb_dev* dev) {
+FN_INTERNAL int upload_firmware(fnusb_dev* dev) {
 	freenect_context* ctx = dev->parent->parent;
 	bootloader_command bootcmd;
 	memset(&bootcmd, 0, sizeof(bootcmd));
@@ -247,7 +248,7 @@ int upload_firmware(fnusb_dev* dev) {
 	return 0;
 }
 
-int upload_cemd_data(fnusb_dev* dev) {
+FN_INTERNAL int upload_cemd_data(fnusb_dev* dev) {
 	// Now we upload the CEMD data.
 	freenect_context* ctx = dev->parent->parent;
 	cemdloader_command cemdcmd;
--- libfreenect-0.1.2+dfsg.orig/src/freenect_internal.h
+++ libfreenect-0.1.2+dfsg/src/freenect_internal.h
@@ -36,6 +36,13 @@
 #include "libfreenect-audio.h"
 #endif
 
+#ifdef __ELF__
+#define FN_INTERNAL	__attribute__ ((visibility ("hidden")))
+#else
+#define FN_INTERNAL
+#endif
+
+
 typedef void (*fnusb_iso_cb)(freenect_device *dev, uint8_t *buf, int len);
 
 #include "usb_libusb10.h"
@@ -89,16 +96,24 @@ static inline uint32_t fn_le32(uint32_t
 static inline int16_t fn_le16s(int16_t s)
 {
 	// reinterpret cast to unsigned, use the normal fn_le16, and then reinterpret cast back
-	uint16_t temp = (*(uint16_t*)(&s));
-	temp = fn_le16(temp);
-	return *((int16_t*)(&temp));
+	union {
+		int16_t s;
+		uint16_t u;
+	} conversion_union;
+	conversion_union.s = s;
+	conversion_union.u = fn_le16(conversion_union.u);
+	return conversion_union.s;
 }
 static inline int32_t fn_le32s(int32_t s)
 {
 	// reinterpret cast to unsigned, use the normal fn_le32, and then reinterpret cast back
-	uint32_t temp = (*(uint32_t*)(&s));
-	temp = fn_le32(temp);
-	return *((int32_t*)(&temp));
+	union {
+		int32_t s;
+		uint32_t u;
+	} conversion_union;
+	conversion_union.s = s;
+	conversion_union.u = fn_le32(conversion_union.u);
+	return conversion_union.s;
 }
 #else
 #define fn_le16(x) (x)
@@ -117,6 +132,13 @@ static inline int32_t fn_le32s(int32_t s
 #define PID_NUI_AUDIO 0x02ad
 #define PID_NUI_CAMERA 0x02ae
 #define PID_NUI_MOTOR 0x02b0
+#define PID_K4W_CAMERA 0x02bf
+#define PID_K4W_AUDIO 0x02be
+
+typedef enum {
+	HWREV_XBOX360_0 = 0,
+	HWREV_K4W_0 = 1,
+} hardware_revision;
 
 typedef struct {
 	int running;
@@ -188,6 +210,8 @@ struct _freenect_device {
 	freenect_device *next;
 	void *user_data;
 
+	hardware_revision hwrev;
+
 	// Cameras
 	fnusb_dev usb_cam;
 	fnusb_isoc_stream depth_isoc;
--- libfreenect-0.1.2+dfsg.orig/include/libfreenect.h
+++ libfreenect-0.1.2+dfsg/include/libfreenect.h
@@ -127,6 +127,18 @@ typedef struct {
 	int8_t is_valid;                /**< If 0, this freenect_frame_mode is invalid and does not describe a supported mode.  Otherwise, the frame_mode is valid. */
 } freenect_frame_mode;
 
+/// Enumeration of smoothing modes
+typedef enum {
+	FREENECT_SMOOTHING_DISABLED                             = 0,
+	FREENECT_SMOOTHING_HOLE_FILLING_DEPTH_SMOOTHING_ENABLED = 1,
+} freenect_smoothing_mode;
+	
+/// Enumeration of range modes
+typedef enum {
+	FREENECT_RANGE_DEFAULT   = 0, /**< default range */
+	FREENECT_RANGE_NEAR_MODE = 1, /**< near mode. Supported by Kinect for Windows only */
+} freenect_range_mode;
+
 /// Enumeration of LED states
 /// See http://openkinect.org/wiki/Protocol_Documentation#Setting_LED for more information.
 typedef enum {
@@ -615,6 +627,28 @@ FREENECTAPI freenect_frame_mode freenect
  */
 FREENECTAPI int freenect_set_depth_mode(freenect_device* dev, const freenect_frame_mode mode);
 
+/**
+ * Enables or disables hole filling/depth smoothing.  The depth stream
+ * must be active as this appears to be reset when it is started.
+ *
+ * @param mode New smoothing mode
+ *
+ * @return 0 on success, < 0 on error
+ */
+FREENECTAPI int freenect_set_smoothing_mode(freenect_device* dev, const freenect_smoothing_mode mode);
+
+/**
+ * Set the range mode. The near mode introduced with the Kinect for
+ * Windows device allows the sensor to see objects closer to it. The
+ * depth stream must be active as this appears to be reset when it is
+ * started.
+ *
+ * @param mode New range mode
+ *
+ * @return 0 on success, < 0 on error
+ */
+FREENECTAPI int freenect_set_range_mode(freenect_device* dev, const freenect_range_mode mode);
+		
 #ifdef __cplusplus
 }
 #endif
--- libfreenect-0.1.2+dfsg.orig/fakenect/CMakeLists.txt
+++ libfreenect-0.1.2+dfsg/fakenect/CMakeLists.txt
@@ -11,11 +11,10 @@ set_target_properties ( fakenect PROPERT
 
 install (TARGETS fakenect
   DESTINATION "${PROJECT_LIBRARY_INSTALL_DIR}/fakenect")
-target_link_libraries(fakenect ${MATH_LIB})
 
-add_executable(fakenect-record record.c)
-target_link_libraries(fakenect-record freenect)
-install (TARGETS fakenect-record
+add_executable(record record.c)
+target_link_libraries(record freenect m)
+install (TARGETS record
   DESTINATION bin)
 
 CONFIGURE_FILE("fakenect.sh.in"
@@ -24,4 +23,3 @@ CONFIGURE_FILE("fakenect.sh.in"
 install (PROGRAMS ${CMAKE_CURRENT_BINARY_DIR}/fakenect.sh
   DESTINATION bin
   RENAME fakenect)
-INSTALL(FILES "README" DESTINATION "share/doc/" RENAME "README.fakenect")
--- libfreenect-0.1.2+dfsg.orig/examples/CMakeLists.txt
+++ libfreenect-0.1.2+dfsg/examples/CMakeLists.txt
@@ -58,6 +58,11 @@ else()
 
   include_directories(${OPENGL_INCLUDE_DIRS} ${GLUT_INCLUDE_DIRS} ${USB_INCLUDE_DIRS})
 
+  if (WIN32)
+    set(MATH_LIB "")
+  else(WIN32)
+    set(MATH_LIB "m")
+  endif()
 
   target_link_libraries(glview freenect ${OPENGL_LIBRARIES} ${GLUT_LIBRARY} ${CMAKE_THREAD_LIBS_INIT} ${MATH_LIB})
   target_link_libraries(regview freenect ${OPENGL_LIBRARIES} ${GLUT_LIBRARY} ${CMAKE_THREAD_LIBS_INIT} ${MATH_LIB})
--- libfreenect-0.1.2+dfsg.orig/examples/hiview.c
+++ libfreenect-0.1.2+dfsg/examples/hiview.c
@@ -68,7 +68,6 @@ GLuint gl_rgb_tex;
 
 freenect_context *f_ctx;
 freenect_device *f_dev;
-int freenect_led;
 
 freenect_video_format requested_format = FREENECT_VIDEO_RGB;
 freenect_video_format current_format = FREENECT_VIDEO_RGB;
@@ -360,7 +359,6 @@ void video_cb(freenect_device *dev, void
 
 void *freenect_threadfunc(void *arg)
 {
-	freenect_set_led(f_dev,LED_RED);
 	freenect_set_depth_callback(f_dev, depth_cb);
 	freenect_set_video_callback(f_dev, video_cb);
 	freenect_set_video_mode(f_dev, freenect_find_video_mode(current_resolution, current_format));
@@ -436,7 +434,7 @@ int main(int argc, char **argv)
 	}
 
 	freenect_set_log_level(f_ctx, FREENECT_LOG_DEBUG);
-	freenect_select_subdevices(f_ctx, (freenect_device_flags)(FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA));
+	freenect_select_subdevices(f_ctx, FREENECT_DEVICE_CAMERA);
 
 	int nr_devices = freenect_num_devices (f_ctx);
 	printf ("Number of devices found: %d\n", nr_devices);
--- libfreenect-0.1.2+dfsg.orig/examples/glview.c
+++ libfreenect-0.1.2+dfsg/examples/glview.c
@@ -67,11 +67,16 @@ GLuint gl_rgb_tex;
 freenect_context *f_ctx;
 freenect_device *f_dev;
 int freenect_angle = 0;
-int freenect_led;
 
 freenect_video_format requested_format = FREENECT_VIDEO_RGB;
 freenect_video_format current_format = FREENECT_VIDEO_RGB;
 
+freenect_smoothing_mode requested_smoothing = FREENECT_SMOOTHING_HOLE_FILLING_DEPTH_SMOOTHING_ENABLED;
+freenect_smoothing_mode current_smoothing = FREENECT_SMOOTHING_HOLE_FILLING_DEPTH_SMOOTHING_ENABLED;
+
+freenect_range_mode requested_range = FREENECT_RANGE_DEFAULT;
+freenect_range_mode current_range = FREENECT_RANGE_DEFAULT;
+
 pthread_cond_t gl_frame_cond = PTHREAD_COND_INITIALIZER;
 int got_rgb = 0;
 int got_depth = 0;
@@ -179,29 +184,18 @@ void keyPressed(unsigned char key, int x
 			freenect_angle = -30;
 		}
 	}
-	if (key == '1') {
-		freenect_set_led(f_dev,LED_GREEN);
-	}
-	if (key == '2') {
-		freenect_set_led(f_dev,LED_RED);
-	}
-	if (key == '3') {
-		freenect_set_led(f_dev,LED_YELLOW);
-	}
-	if (key == '4') {
-		freenect_set_led(f_dev,LED_BLINK_GREEN);
-	}
-	if (key == '5') {
-		// 5 is the same as 4
-		freenect_set_led(f_dev,LED_BLINK_GREEN);
-	}
-	if (key == '6') {
-		freenect_set_led(f_dev,LED_BLINK_RED_YELLOW);
+	if (key == 'm') {
+		if (requested_smoothing == FREENECT_SMOOTHING_DISABLED)
+			requested_smoothing = FREENECT_SMOOTHING_HOLE_FILLING_DEPTH_SMOOTHING_ENABLED;
+		else
+			requested_smoothing = FREENECT_SMOOTHING_DISABLED;
 	}
-	if (key == '0') {
-		freenect_set_led(f_dev,LED_OFF);
+	if (key == 'n') {
+		if (requested_range == FREENECT_RANGE_DEFAULT)
+			requested_range = FREENECT_RANGE_NEAR_MODE;
+		else
+			requested_range = FREENECT_RANGE_DEFAULT;
 	}
-	freenect_set_tilt_degs(f_dev,freenect_angle);
 }
 
 void ReSizeGLScene(int Width, int Height)
@@ -335,10 +329,6 @@ void rgb_cb(freenect_device *dev, void *
 
 void *freenect_threadfunc(void *arg)
 {
-	int accelCount = 0;
-
-	freenect_set_tilt_degs(f_dev,freenect_angle);
-	freenect_set_led(f_dev,LED_RED);
 	freenect_set_depth_callback(f_dev, depth_cb);
 	freenect_set_video_callback(f_dev, rgb_cb);
 	freenect_set_video_mode(f_dev, freenect_find_video_mode(FREENECT_RESOLUTION_MEDIUM, current_format));
@@ -348,28 +338,21 @@ void *freenect_threadfunc(void *arg)
 	freenect_start_depth(f_dev);
 	freenect_start_video(f_dev);
 
-	printf("'w'-tilt up, 's'-level, 'x'-tilt down, '0'-'6'-select LED mode, 'f'-video format\n");
-
 	while (!die && freenect_process_events(f_ctx) >= 0) {
-		//Throttle the text output
-		if (accelCount++ >= 2000)
-		{
-			accelCount = 0;
-			freenect_raw_tilt_state* state;
-			freenect_update_tilt_state(f_dev);
-			state = freenect_get_tilt_state(f_dev);
-			double dx,dy,dz;
-			freenect_get_mks_accel(state, &dx, &dy, &dz);
-			printf("\r raw acceleration: %4d %4d %4d  mks acceleration: %4f %4f %4f", state->accelerometer_x, state->accelerometer_y, state->accelerometer_z, dx, dy, dz);
-			fflush(stdout);
-		}
-
 		if (requested_format != current_format) {
 			freenect_stop_video(f_dev);
 			freenect_set_video_mode(f_dev, freenect_find_video_mode(FREENECT_RESOLUTION_MEDIUM, requested_format));
 			freenect_start_video(f_dev);
 			current_format = requested_format;
 		}
+		if (requested_smoothing != current_smoothing){
+			freenect_set_smoothing_mode(f_dev, requested_smoothing);
+			current_smoothing = requested_smoothing;
+		}
+		if (requested_range != current_range){
+			freenect_set_range_mode(f_dev, requested_range);
+			current_range = requested_range;
+		}
 	}
 
 	printf("\nshutting down streams...\n");
@@ -411,8 +394,8 @@ int main(int argc, char **argv)
 		return 1;
 	}
 
-	freenect_set_log_level(f_ctx, FREENECT_LOG_DEBUG);
-	freenect_select_subdevices(f_ctx, (freenect_device_flags)(FREENECT_DEVICE_MOTOR | FREENECT_DEVICE_CAMERA));
+	freenect_set_log_level(f_ctx, FREENECT_LOG_INFO);
+	freenect_select_subdevices(f_ctx, (freenect_device_flags)(FREENECT_DEVICE_CAMERA));
 
 	int nr_devices = freenect_num_devices (f_ctx);
 	printf ("Number of devices found: %d\n", nr_devices);
--- libfreenect-0.1.2+dfsg.orig/cmake_modules/FindOS.cmake
+++ libfreenect-0.1.2+dfsg/cmake_modules/FindOS.cmake
@@ -46,3 +46,14 @@ ENDIF (PROJECT_OS_LINUX)
 
 MESSAGE (STATUS "Got System Processor ${CMAKE_SYSTEM_PROCESSOR}")
 
+# 32 or 64 bit Linux
+IF (PROJECT_OS_LINUX)
+    # Set the library directory suffix accordingly
+    IF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
+        SET (PROJECT_PROC_64BIT TRUE BOOL INTERNAL)
+        MESSAGE (STATUS "Linux x86_64 Detected")
+    ELSEIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "ppc64")
+        MESSAGE (STATUS "Linux ppc64 Detected")
+        SET (PROJECT_PROC_64BIT TRUE BOOL INTERNAL)
+    ENDIF (${CMAKE_SYSTEM_PROCESSOR} STREQUAL "x86_64")
+ENDIF (PROJECT_OS_LINUX)
--- libfreenect-0.1.2+dfsg.orig/cmake_modules/SetupDirectories.cmake
+++ libfreenect-0.1.2+dfsg/cmake_modules/SetupDirectories.cmake
@@ -9,12 +9,15 @@ MESSAGE (STATUS "${PROJECT_NAME} will be
 
 # Installation prefix for include files
 STRING (TOLOWER ${PROJECT_NAME} projectNameLower)
-#SET (PROJECT_INCLUDE_INSTALL_DIR "include/${projectNameLower}")
-SET (PROJECT_INCLUDE_INSTALL_DIR "include")
+SET (PROJECT_INCLUDE_INSTALL_DIR "include/${projectNameLower}")
 
-IF (NOT DEFINED PROJECT_LIBRARY_INSTALL_DIR)
-	SET (PROJECT_LIBRARY_INSTALL_DIR "lib" CACHE PATH "object code libraries")
-ENDIF ()
+IF (PROJECT_PROC_64BIT)
+    SET (LIB_SUFFIX "64" CACHE STRING "Suffix for library installation directory")
+ELSE (PROJECT_PROC_64BIT)
+    SET (LIB_SUFFIX "" CACHE STRING "Suffix for library installation directory")
+ENDIF (PROJECT_PROC_64BIT)
+
+SET (PROJECT_LIBRARY_INSTALL_DIR "lib${LIB_SUFFIX}")
 
 MESSAGE (STATUS "Headers will be installed to ${CMAKE_INSTALL_PREFIX}/${PROJECT_INCLUDE_INSTALL_DIR}")
 MESSAGE (STATUS "Libraries will be installed to ${CMAKE_INSTALL_PREFIX}/${PROJECT_LIBRARY_INSTALL_DIR}")
